<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Pattern Toolkit</title>
    <!-- 1. Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. three.js for 3D Guilloche -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 3. OrbitControls for 3D interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the 3D canvas container */
        #guilloche-3d-container {
            width: 100%;
            height: 500px;
            border-radius: 0.5rem;
            overflow: hidden;
            background: #111827; /* Dark background for 3D view */
        }
        /* Style for 2D canvases */
        canvas.pattern-canvas {
            background: #ffffff;
            border-radius: 0.5rem;
            width: 100%;
            height: 500px;
            border: 1px solid #374151;
        }
        /* ASCII output */
        #ascii-output {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            overflow-x: auto;
            background: #1f2937;
            color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            line-height: 1.0;
            font-size: 8px; /* Start with small font for density */
        }
        /* Tab button styling */
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #374151;
            color: #d1d5db;
        }
        .tab-btn.active {
            background-color: #4f46e5;
            color: #ffffff;
        }
        /* Hide non-active tabs */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Custom range slider style */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563; /* gray-600 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            border-radius: 50%;
            cursor: pointer;
        }
        /* Custom text input */
        .text-input {
            width: 100%;
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            color: #f3f4f6;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .text-input:focus {
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px #4f46e5;
        }
        /* Button styles */
        .btn {
            w-full h-10 mt-auto font-bold py-2 px-4 rounded-md transition-colors duration-200;
        }
        .btn-green {
            @apply btn bg-green-600 hover:bg-green-700 text-white;
        }
        .btn-indigo {
            @apply btn bg-indigo-600 hover:bg-indigo-700 text-white;
        }
        .btn-gray {
            @apply btn bg-gray-600 hover:bg-gray-700 text-white;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Security Pattern Toolkit</h1>
            <p class="text-lg text-gray-400">A comprehensive collection of generative security tools.</p>
        </header>

        <!-- Tab Navigation -->
        <nav class="flex flex-wrap gap-2 justify-center mb-8" id="tab-nav">
            <button class="tab-btn active" data-tab="tab-ascii">1. Image to ASCII</button>
            <button class="tab-btn" data-tab="tab-guilloche-2d">2. 2D Guilloche</button>
            <button class="tab-btn" data-tab="tab-guilloche-3d">3. 3D Guilloche</button>
            <button class="tab-btn" data-tab="tab-security-pattern">4. Complex Security Pattern</button>
        </nav>

        <!-- Tab Content Area -->
        <main>

            <!-- =================================== -->
            <!--   Tab 1: Image to ASCII (Upgraded)  -->
            <!-- =================================== -->
            <div id="tab-ascii" class="tab-content active">
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-white">1. Image to ASCII Converter</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="ascii-file" class="block text-sm font-medium text-gray-300 mb-1">Upload Image</label>
                            <input type="file" id="ascii-file" accept="image/*" class="w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
                        </div>
                        <div>
                            <label for="ascii-resolution" class="block text-sm font-medium text-gray-300 mb-1">Resolution (Scale: <span id="ascii-res-label">0.2</span>)</label>
                            <input type="range" id="ascii-resolution" min="0.05" max="1.0" step="0.05" value="0.2" class="w-full">
                        </div>
                        <div>
                            <label for="ascii-text" class="block text-sm font-medium text-gray-300 mb-1">Fill Text (Repeated)</label>
                            <input type="text" id="ascii-text" class="text-input" value="SECURE ">
                        </div>
                        <div>
                            <label for="ascii-density-ramp" class="block text-sm font-medium text-gray-300 mb-1">Density Ramp (Dark to Light)</label>
                            <input type="text" id="ascii-density-ramp" class="text-input" value=" .:-=+*#%@">
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <button id="ascii-generate" class="w-full h-10 font-bold py-2 px-4 rounded-md transition-colors duration-200 bg-green-600 hover:bg-green-700 text-white">Generate ASCII</button>
                        <button id="ascii-download" class="w-full h-10 font-bold py-2 px-4 rounded-md transition-colors duration-200 bg-gray-600 hover:bg-gray-700 text-white">Download as .txt</button>
                    </div>

                    <div class="mt-6">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Output:</label>
                        <pre id="ascii-output">Upload an image and click "Generate".</pre>
                    </div>
                    
                    <!-- Hidden canvas for image processing -->
                    <canvas id="ascii-canvas" class="hidden"></canvas>
                </div>
            </div>

            <!-- =================================== -->
            <!--   Tab 2: 2D Guilloche (Rebuilt)     -->
            <!-- =================================== -->
            <div id="tab-guilloche-2d" class="tab-content">
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-white">2. 2D Guilloche Generator</h2>
                    
                    <canvas id="guilloche-2d-canvas" class="pattern-canvas"></canvas>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
                        <div>
                            <label for="g2d-seed" class="block text-sm font-medium text-gray-300">Pattern Seed (Your "Code")</label>
                            <input type="text" id="g2d-seed" class="text-input h-10" placeholder="Enter any text or number...">
                        </div>
                        <button id="guilloche-2d-generate" class="w-full h-10 mt-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                            Generate
                        </button>
                        <button id="guilloche-2d-random" class="w-full h-10 mt-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                            Randomize
                        </button>
                    </div>
                    <button id="guilloche-2d-download" class="w-full h-10 mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                        Download as .png
                    </button>
                    
                    <h3 class="text-lg font-semibold text-white mt-8 mb-4">Pattern Parameters (Controlled by Seed)</h3>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-6">
                        <!-- Sliders for parameters -->
                        <div>
                            <label for="g2d-R1" class="block text-sm font-medium text-gray-300">Blue Outer R (<span id="g2d-R1-label">150</span>)</label>
                            <input type="range" id="g2d-R1" min="50" max="250" value="150" class="w-full" disabled>
                        </div>
                        <div>
                            <label for="g2d-r1" class="block text-sm font-medium text-gray-300">Blue Inner r (<span id="g2d-r1-label">60</span>)</label>
                            <input type="range" id="g2d-r1" min="10" max="120" value="60" class="w-full" disabled>
                        </div>
                        <div>
                            <label for="g2d-d1" class="block text-sm font-medium text-gray-300">Blue Offset d (<span id="g2d-d1-label">80</span>)</label>
                            <input type="range" id="g2d-d1" min="10" max="150" value="80" class="w-full" disabled>
                        </div>
                        <div>
                            <label for="g2d-R2" class="block text-sm font-medium text-gray-300">Green Outer R (<span id="g2d-R2-label">180</span>)</label>
                            <input type="range" id="g2d-R2" min="50" max="250" value="180" class="w-full" disabled>
                        </div>
                        <div>
                            <label for="g2d-r2" class="block text-sm font-medium text-gray-300">Green Inner r (<span id="g2d-r2-label">40</span>)</label>
                            <input type="range" id="g2d-r2" min="10" max="120" value="40" class="w-full" disabled>
                        </div>
                        <div>
                            <label for="g2d-d2" class="block text-sm font-medium text-gray-300">Green Offset d (<span id="g2d-d2-label">100</span>)</label>
                            <input type="range" id="g2d-d2" min="10" max="150" value="100" class="w-full" disabled>
                        </div>
                    </div>
                </div>
            </div>

            <!-- =================================== -->
            <!--   Tab 3: 3D Guilloche Generator     -->
            <!-- =================================== -->
            <div id="tab-guilloche-3d" class="tab-content">
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-white">3. 3D Guilloche Generator (Torus Knot)</h2>
                    <p class="text-gray-400 mb-4">Click and drag to rotate. Scroll to zoom. Sliders update the model in real-time.</p>
                    
                    <div id="guilloche-3d-container"></div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-6">
                        <!-- Sliders for parameters -->
                        <div>
                            <label for="g3d-p" class="block text-sm font-medium text-gray-300">P (Windings: <span id="g3d-p-label">2</span>)</label>
                            <input type="range" id="g3d-p" min="1" max="10" value="2" step="1" class="w-full">
                        </div>
                        <div>
                            <label for="g3d-q" class="block text-sm font-medium text-gray-300">Q (Windings: <span id="g3d-q-label">3</span>)</label>
                            <input type="range" id="g3d-q" min="1" max="10" value="3" step="1" class="w-full">
                        </div>
                        <div>
                            <label for="g3d-radius" class="block text-sm font-medium text-gray-300">Radius (<span id="g3d-radius-label">2.0</span>)</label>
                            <input type="range" id="g3d-radius" min="0.5" max="5" value="2" step="0.1" class="w-full">
                        </div>
                        <div>
                            <label for="g3d-tube" class="block text-sm font-medium text-gray-300">Tube (<span id="g3d-tube-label">0.8</span>)</label>
                            <input type="range" id="g3d-tube" min="0.1" max="2" value="0.8" step="0.1" class="w-full">
                        </div>
                    </div>
                    <button id="guilloche-3d-download" class="w-full h-10 mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                        Download as .png
                    </button>
                </div>
            </div>

            <!-- =================================== -->
            <!--   Tab 4: Complex Security (Upgraded) -->
            <!-- =================================== -->
            <div id="tab-security-pattern" class="tab-content">
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-4 text-white">4. Difficult Security Pattern (Example)</h2>
                    
                    <canvas id="security-pattern-canvas" class="pattern-canvas"></canvas>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
                        <div class="md:col-span-2">
                            <label for="microtext-input" class="block text-sm font-medium text-gray-300">Custom Microtext</label>
                            <input type="text" id="microtext-input" class="text-input h-10" value="SECURE DOCUMENT - ">
                        </div>
                        <button id="microtext-generate" class="w-full h-10 mt-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                            Redraw with Text
                        </button>
                    </div>
                    <button id="security-pattern-download" class="w-full h-10 mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200">
                        Download as .png
                    </button>
                    
                    <div class="mt-6 text-gray-300">
                        <h3 class="text-lg font-semibold text-white">Why this is hard to forge:</h3>
                        <p class="mt-2">This static pattern demonstrates a "multi-layered" security approach...</p>
                        <!-- Description unchanged -->
                    </div>
                </div>
            </div>

        </main>
    </div>

    <script type="module">
        // Global state
        let is3DInitialized = false;

        // --- Download Helper Function ---
        function downloadData(dataUrl, filename) {
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function downloadBlob(blob, filename) {
             const url = URL.createObjectURL(blob);
             downloadData(url, filename);
             URL.revokeObjectURL(url);
        }

        // --- Tab Switching Logic ---
        const tabNav = document.getElementById('tab-nav');
        const tabContents = document.querySelectorAll('.tab-content');
        const tabButtons = document.querySelectorAll('.tab-btn');

        tabNav.addEventListener('click', (e) => {
            const clickedButton = e.target.closest('.tab-btn');
            if (!clickedButton) return;

            const tabId = clickedButton.dataset.tab;

            // Update buttons
            tabButtons.forEach(btn => {
                btn.classList.remove('active');
            });
            clickedButton.classList.add('active');

            // Update content
            tabContents.forEach(content => {
                if (content.id === tabId) {
                    content.classList.add('active');
                    // Check if we need to initialize a tool
                    if (tabId === 'tab-guilloche-3d' && !is3DInitialized) {
                        init3D();
                        is3DInitialized = true;
                    }
                    if (tabId === 'tab-guilloche-2d') {
                        // Generate a default pattern on first load
                        if(document.getElementById('g2d-seed').value === "") {
                            document.getElementById('g2d-seed').value = "default-pattern-123";
                            generateFromSeed();
                        }
                    }
                    if (tabId === 'tab-security-pattern') {
                        drawSecurityPattern();
                    }
                } else {
                    content.classList.remove('active');
                }
            });
        });

        // --- Tool 1: Image to ASCII (Upgraded Logic) ---
        const asciiFile = document.getElementById('ascii-file');
        const asciiCanvas = document.getElementById('ascii-canvas');
        const asciiCtx = asciiCanvas.getContext('2d');
        const asciiOutput = document.getElementById('ascii-output');
        const asciiGenerate = document.getElementById('ascii-generate');
        const asciiDownload = document.getElementById('ascii-download');
        const asciiResolution = document.getElementById('ascii-resolution');
        const asciiResLabel = document.getElementById('ascii-res-label');
        const asciiText = document.getElementById('ascii-text');
        const asciiDensityRamp = document.getElementById('ascii-density-ramp');
        let rawImage = null;

        asciiFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                rawImage = new Image();
                rawImage.onload = () => {
                    asciiOutput.textContent = "Image loaded. Click 'Generate' to convert.";
                }
                rawImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        asciiResolution.addEventListener('input', (e) => {
            asciiResLabel.textContent = parseFloat(e.target.value).toFixed(2);
        });

        asciiGenerate.addEventListener('click', () => {
            if (!rawImage) {
                asciiOutput.textContent = "Please upload an image first.";
                return;
            }

            const scale = parseFloat(asciiResolution.value);
            const fillText = asciiText.value || "X";
            const fillLen = fillText.length;
            const densityRamp = asciiDensityRamp.value || " ";
            const rampLen = densityRamp.length;

            let w = rawImage.width;
            let h = rawImage.height;
            let newWidth = w * scale;
            let newHeight = h * scale;
            newHeight /= 2;
            
            newWidth = Math.max(1, Math.floor(newWidth));
            newHeight = Math.max(1, Math.floor(newHeight));

            asciiCanvas.width = newWidth;
            asciiCanvas.height = newHeight;
            asciiCtx.drawImage(rawImage, 0, 0, newWidth, newHeight);

            const imageData = asciiCtx.getImageData(0, 0, newWidth, newHeight);
            const data = imageData.data;
            let asciiStr = '';

            for (let y = 0; y < newHeight; y++) {
                for (let x = 0; x < newWidth; x++) {
                    const i = (y * newWidth + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                    const rampIndex = Math.min(rampLen - 1, Math.floor(brightness * rampLen));
                    const densityChar = densityRamp[rampIndex];
                    const fillChar = fillText[(y * newWidth + x) % fillLen];
                    
                    asciiStr += (densityChar === ' ') ? ' ' : fillChar;
                }
                asciiStr += '\n';
            }
            asciiOutput.textContent = asciiStr;
        });
        
        asciiDownload.addEventListener('click', () => {
            const text = asciiOutput.textContent;
            if (!text || text === "Upload an image and click \"Generate\".") return;
            const blob = new Blob([text], { type: 'text/plain' });
            downloadBlob(blob, 'ascii-art.txt');
        });


        // --- Tool 2: 2D Guilloche (Rebuilt Engine) ---
        const g2dCanvas = document.getElementById('guilloche-2d-canvas');
        const g2dCtx = g2dCanvas.getContext('2d');
        const g2dGenerate = document.getElementById('guilloche-2d-generate');
        const g2dRandom = document.getElementById('guilloche-2d-random');
        const g2dDownload = document.getElementById('guilloche-2d-download');
        const g2dSeedInput = document.getElementById('g2d-seed');
        const g2dSliders = {
            R1: document.getElementById('g2d-R1'),
            r1: document.getElementById('g2d-r1'),
            d1: document.getElementById('g2d-d1'),
            R2: document.getElementById('g2d-R2'),
            r2: document.getElementById('g2d-r2'),
            d2: document.getElementById('g2d-d2'),
        };
        const g2dLabels = {
            R1: document.getElementById('g2d-R1-label'),
            r1: document.getElementById('g2d-r1-label'),
            d1: document.getElementById('g2d-d1-label'),
            R2: document.getElementById('g2d-R2-label'),
            r2: document.getElementById('g2d-r2-label'),
            d2: document.getElementById('g2d-d2-label'),
        };

        // --- PRNG and Hashing (unchanged) ---
        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277,
                h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return (h1^h2^h3^h4)>>>0;
        }

        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        
        function gcd(a, b) {
            if (b === 0) return a;
            return gcd(b, a % b);
        }
        
        // --- New Hypotrochoid Drawing Engine ---
        function drawHypotrochoid(ctx, w, h, R, r, d, color) {
            const centerX = w / 2;
            const centerY = h / 2;
            const bandWidth = 8;
            const lineStep = 0.2; 
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.3; 

            for (let offset = d - (bandWidth/2); offset <= d + (bandWidth/2); offset += lineStep) {
                ctx.beginPath();
                
                const r_gcd = gcd(R, r);
                const endT = 2 * Math.PI * r / r_gcd;
                const tStep = endT / 2000; // Use a high fixed step count for smoothness

                for (let t = 0; t <= endT + tStep; t += tStep) {
                    const x = (R - r) * Math.cos(t) + offset * Math.cos(((R - r) / r) * t);
                    const y = (R - r) * Math.sin(t) - offset * Math.sin(((R - r) / r) * t);
                    
                    if (t === 0) {
                        ctx.moveTo(centerX + x, centerY + y);
                    } else {
                        ctx.lineTo(centerX + x, centerY + y);
                    }
                }
                ctx.stroke();
            }
        }

        function generateFromSeed() {
            let seedStr = g2dSeedInput.value;
            if (seedStr === "") {
                seedStr = Math.random().toString(36).substring(7);
                g2dSeedInput.value = seedStr;
            }

            const seed = cyrb128(seedStr);
            const rand = mulberry32(seed);

            const params1 = {
                R: Math.floor(rand() * 200) + 50,
                r: Math.floor(rand() * 110) + 10,
                d: Math.floor(rand() * 140) + 10,
            };
            const params2 = {
                R: Math.floor(rand() * 200) + 50,
                r: Math.floor(rand() * 110) + 10,
                d: Math.floor(rand() * 140) + 10,
            };

            // Ensure r is not equal to R
            if (params1.r === params1.R) params1.r -= 1;
            if (params2.r === params2.R) params2.r -= 1;

            for (const [key, value] of Object.entries(params1)) {
                g2dSliders[key+"1"].value = value;
                g2dLabels[key+"1"].textContent = value;
            }
            for (const [key, value] of Object.entries(params2)) {
                g2dSliders[key+"2"].value = value;
                g2dLabels[key+"2"].textContent = value;
            }

            const w = g2dCanvas.width;
            const h = g2dCanvas.height;
            g2dCtx.clearRect(0, 0, w, h);
            drawHypotrochoid(g2dCtx, w, h, params1.R, params1.r, params1.d, "rgba(59, 130, 246, 0.7)");
            drawHypotrochoid(g2dCtx, w, h, params2.R, params2.r, params2.d, "rgba(16, 185, 129, 0.7)");
        }

        g2dGenerate.addEventListener('click', generateFromSeed);
        g2dRandom.addEventListener('click', () => {
            g2dSeedInput.value = Math.random().toString(36).substring(2, 10);
            generateFromSeed();
        });
        g2dDownload.addEventListener('click', () => {
            const dataUrl = g2dCanvas.toDataURL('image/png');
            downloadData(dataUrl, `guilloche-${g2dSeedInput.value || 'pattern'}.png`);
        });


        // --- Tool 3: 3D Guilloche ---
        let scene, camera, renderer, controls, mesh;
        const g3dContainer = document.getElementById('guilloche-3d-container');
        const g3dDownload = document.getElementById('guilloche-3d-download');
        const g3dSliders = {
            p: document.getElementById('g3d-p'),
            q: document.getElementById('g3d-q'),
            radius: document.getElementById('g3d-radius'),
            tube: document.getElementById('g3d-tube'),
        };
        const g3dLabels = {
            p: document.getElementById('g3d-p-label'),
            q: document.getElementById('g3d-q-label'),
            radius: document.getElementById('g3d-radius-label'),
            tube: document.getElementById('g3d-tube-label'),
        };


        function init3D() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            const w = g3dContainer.clientWidth;
            const h = g3dContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true // CRITICAL for downloading
            });
            renderer.setSize(w, h);
            renderer.setClearColor(0x111827); // Match container bg
            g3dContainer.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Initial geometry
            generate3DGuilloche();

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); 
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', () => {
                const w = g3dContainer.clientWidth;
                const h = g3dContainer.clientHeight;
                if(w > 0 && h > 0) {
                    renderer.setSize(w, h);
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                }
            });

            // Add event listeners to sliders
            for (const [key, slider] of Object.entries(g3dSliders)) {
                slider.addEventListener('input', (e) => {
                    let value = parseFloat(e.target.value);
                    g3dLabels[key].textContent = value.toFixed(key === 'radius' || key === 'tube' ? 1 : 0);
                    generate3DGuilloche();
                });
            }
        }

        function generate3DGuilloche() {
            if(!scene) return; 

            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            }

            const p = +g3dSliders.p.value;
            const q = +g3dSliders.q.value;
            const radius = +g3dSliders.radius.value;
            const tube = +g3dSliders.tube.value;

            const geometry = new THREE.TorusKnotGeometry(radius, tube, 150, 20, p, q);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, // Bright green
                wireframe: true 
            });
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
        }
        
        g3dDownload.addEventListener('click', () => {
            if (!renderer) return;
            // Force a render to make sure the buffer is correct
            renderer.render(scene, camera); 
            const dataUrl = renderer.domElement.toDataURL('image/png');
            downloadData(dataUrl, '3d-guilloche.png');
        });

        // --- Tool 4: Complex Security Pattern (Upgraded) ---
        const spCanvas = document.getElementById('security-pattern-canvas');
        const spCtx = spCanvas.getContext('2d');
        const microtextInput = document.getElementById('microtext-input');
        const microtextGenerate = document.getElementById('microtext-generate');
        const spDownload = document.getElementById('security-pattern-download');

        function drawSecurityPattern() {
            const w = spCanvas.width;
            const h = spCanvas.height;
            spCtx.clearRect(0, 0, w, h);
            const centerX = w / 2;
            const centerY = h / 2;

            // 1. Draw Halftone dot screen
            spCtx.fillStyle = "#f0f0f0"; // Very light gray
            for (let x = 0; x < w; x += 10) {
                for (let y = 0; y < h; y += 10) {
                    spCtx.beginPath();
                    spCtx.arc(x, y, 1, 0, Math.PI * 2);
                    spCtx.fill();
                }
            }

            // 2. Draw first guilloche (blue)
            spCtx.beginPath();
            spCtx.lineWidth = 0.5;
            spCtx.strokeStyle = "rgba(0, 0, 255, 0.7)";
            let a=180, b=150, c=180, d=150, fA=3, fB=10, fC=7, fD=11;
            for (let i = 0; i <= 2000; i++) {
                const t = (i / 2000) * Math.PI * 10;
                const x = a * Math.cos(fA * t) + b * Math.cos(fB * t);
                const y = c * Math.sin(fC * t) + d * Math.sin(fD * t);
                if (i === 0) spCtx.moveTo(centerX + x, centerY + y);
                else spCtx.lineTo(centerX + x, centerY + y);
            }
            spCtx.stroke();
            
            // 3. Draw second guilloche (green)
            spCtx.beginPath();
            spCtx.lineWidth = 0.5;
            spCtx.strokeStyle = "rgba(0, 255, 0, 0.7)";
            a=200, b=200, c=200, d=200, fA=5, fB=12, fC=2, fD=9;
            for (let i = 0; i <= 2000; i++) {
                const t = (i / 2000) * Math.PI * 10;
                const x = a * Math.cos(fA * t) + b * Math.cos(fB * t);
                const y = c * Math.sin(fC * t) + d * Math.sin(fD * t);
                if (i === 0) spCtx.moveTo(centerX + x, centerY + y);
                else spCtx.lineTo(centerX + x, centerY + y);
            }
            spCtx.stroke();

            // 4. Draw Microtext (from input)
            spCtx.font = "6px Arial";
            spCtx.fillStyle = "rgba(0, 0, 0, 0.6)";
            const text = (microtextInput.value || "SECURE DOCUMENT - ") + " ";
            const fullText = text.repeat(Math.ceil(w / (text.length * 3.5)));
            for (let i = 0; i < fullText.length; i++) {
                const x = 50 + i * 3.5;
                if (x > w - 50) break;
                const y = h / 2 + Math.sin(x / 30) * 20; // Wavy line
                spCtx.save();
                spCtx.translate(x, y);
                spCtx.rotate(Math.cos(x/30) * 0.2);
                spCtx.fillText(fullText[i], 0, 0);
                spCtx.restore();
            }
        }
        
        microtextGenerate.addEventListener('click', drawSecurityPattern);
        spDownload.addEventListener('click', () => {
            const dataUrl = spCanvas.toDataURL('image/png');
            downloadData(dataUrl, 'security-pattern.png');
        });
        
        // --- Initial Load ---
        drawSecurityPattern();

    </script>
</body>
</html>


